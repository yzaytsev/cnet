#!/usr/bin/env ruby

def count_bits(v)
    v = v - ((v >> 1) & 0x55555555)
    v = (v & 0x33333333) + ((v >> 2) & 0x33333333)
    c = (((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) & 0xFFFFFFFF) >> 24
    return c
end

total_bits_count = ARGV[0].nil? ? 4 : ARGV[0].to_i
ones_count       = ARGV[1].nil? ? 4 : ARGV[1].to_i

bytes   = []
indexes = []
found_count = 0
(1 << (total_bits_count)).times do |x|
    if (count_bits(x) == ones_count)
        bytes.push(x)
        indexes.push(found_count)
        found_count += 1
    else
        indexes.push(-1)
    end
end

data_bits_per_code    = Math.log2(bytes.size).to_i
# to ensure that packet is capable to deliver 1K (2^10)
packet_size_field_len = (10.to_f / data_bits_per_code).ceil.to_i

cmd_first_data = ((bytes.size - (1 << data_bits_per_code)) / 2).to_i
cmd_pkt_begin  = cmd_first_data - 1
cmd_extension  = cmd_pkt_begin - 1
cmd_last_data  = cmd_first_data + (1 << data_bits_per_code) - 1
cmd_pkt_end    = cmd_last_data + 1
cmd_fin        = cmd_pkt_end   + 1

##a = [ 0, 0, 0, 0, 1, 1, 1, 1]
#a = []
#zeros_count.to_i.times { a.push(0) }
#ones_count.to_i.times  { a.push(1) }
##puts "stage 1"
#perms = a.permutation.to_a.uniq
##puts "stage 2"
#bytes = []
#perms.each do |bits|
#    num = 0
#    bits.each { |x| num <<= 1; num |= x }
#    bytes.push(num)
#end
#puts "stage 3"

puts <<HEREDOC
#include <net/codemap.h>

/**********************************************************************
 * THIS FILE IS AUTOMATICALLY GENERATED, DO NOT CHANGE IT MANUALLY!
 **********************************************************************/

const cncode_t NO_SUCH_INDEX = #{bytes.max + 1};
const int      NO_SUCH_CODE  =  -1;

const int CMD_EXTENSION  = #{cmd_extension};
const int CMD_PKT_BEGIN  = #{cmd_pkt_begin};
const int CMD_FIRST_DATA = #{cmd_first_data};
const int CMD_LAST_DATA  = #{cmd_last_data};
const int CMD_PKT_END    = #{cmd_pkt_end};
const int CMD_FIN        = #{cmd_fin};

const int DATA_BITS_PER_CODE    = #{data_bits_per_code};
const int PACKET_SIZE_FIELD_LEN = #{packet_size_field_len};

/**
 * This table contains all #{total_bits_count}-bit numbers which have
 * exactly #{ones_count} bits set and #{total_bits_count - ones_count} bits unset. Such numbers are called codes
 * because encoder uses them for passing messages over L3 cache.
 */
static const cncode_t index_to_code_map[] = {
HEREDOC
bytes.each_slice(8) do |line|
    #puts "#{line.join(', ')},"
    puts "    #{line.map { |x| '%3d' % x }.join(', ')},"
end
puts <<HEREDOC
};

HEREDOC

puts <<HEREDOC
/**
 * This table is a reverse of the table above and allows to find code's
 * number (index) in the table above.
 * Number -1 means there is no such code and equals NO_SUCH_CODE constant
 * defined in net/codemap.h file.
 */
static const int code_to_index_map[] = {
HEREDOC
indexes.each_slice(8) do |line|
    puts "    #{line.map { |x| '%3d' % x}.join(', ')},"
end
#(bytes.max + 1).times.to_a.each_slice(8) do |line|
#    puts "    #{line.map { |x| '%3d' % (bytes.index(x).nil? ? -1 : bytes.index(x))}.join(', ')},"
#end
puts <<HEREDOC
};

cncode_t index_to_code(int index) {
    static const int i2c_size = (sizeof(index_to_code_map) / sizeof(index_to_code_map[0]));
    if (index >= i2c_size || index < 0) {
        return NO_SUCH_INDEX;
    }
    return index_to_code_map[index];
}

int code_to_index(cncode_t code) {
    static const unsigned c2i_size = (sizeof(code_to_index_map) / sizeof(code_to_index_map[0]));
    if ((unsigned)code >= c2i_size) {
        return NO_SUCH_CODE;
    }
    return code_to_index_map[code];
}

HEREDOC
