#!/usr/bin/env ruby

a = [ 0, 0, 0, 0, 1, 1, 1, 1]
perms = a.permutation.to_a.uniq
bytes = []
perms.each do |bits|
    num = 0
    bits.each { |x| num <<= 1; num |= x }
    bytes.push(num)
end

puts <<HEREDOC
#include <net/codemap.h>

/**********************************************************************
 * THIS FILE IS AUTOMATICALLY GENERATED, DO NOT CHANGE IT MANUALLY!
 **********************************************************************/

/**
 * This table contains all 8-bit numbers which have
 * exactly 4 bits set and 4 bits unset. Such numbers are called codes
 * because encoder uses them for passing messages over L3 cache.
 */
static const cncode_t index_to_code_map[] = {
HEREDOC
bytes.each_slice(8) do |line|
    #puts "#{line.join(', ')},"
    puts "    #{line.map { |x| '%3d' % x }.join(', ')},"
end
puts <<HEREDOC
};

HEREDOC

puts <<HEREDOC
/**
 * This table is a reverse of the table above and allows to find code's
 * number (index)  * in the table above.<F12>
 * Number -1 means there is no such code and equals NO_SUCH_CODE constant
 * defined in net/codemap.h file.
 */
static const int code_to_index_map[] = {
HEREDOC
(bytes.max + 1).times.to_a.each_slice(8) do |line|
    puts "    #{line.map { |x| '%3d' % (bytes.index(x).nil? ? -1 : bytes.index(x))}.join(', ')},"
end
puts <<HEREDOC
};

cncode_t index_to_code(int index) {
    static const int i2c_size = (sizeof(index_to_code_map) / sizeof(index_to_code_map[0]));
    if (index >= i2c_size || index < 0) {
        return NO_SUCH_INDEX;
    }
    return index_to_code_map[index];
}

int code_to_index(cncode_t code) {
    static const unsigned c2i_size = (sizeof(code_to_index_map) / sizeof(code_to_index_map[0]));
    if ((unsigned)code >= c2i_size) {
        return NO_SUCH_CODE;
    }
    return code_to_index_map[code];
}

HEREDOC
